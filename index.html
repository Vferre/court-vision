<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Court Vision ‚Äî Animated Half-Court Playbook</title>
<meta name="description" content="Animated basketball 5x5 plays on a clean half-court. Numbered players, moving defenders, and pass animations with an orange ball." />
<style>
  :root{
    --bg:#f7f8fb;
    --ink:#111;
    --muted:#555;
    --card:#fff;
    --line:#111;
    --dash:#777;
    --offense:#e53935;    /* red */
    --defense:#111;       /* black */
    --ball:#ff8c00;       /* orange */
    --accent:#1d4ed8;     /* blue (arrows/UI) */
    --radius:14px;
    --shadow:0 4px 16px rgba(0,0,0,.08);
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--ink); background:linear-gradient(#fff,#f4f6fb);
    font-family:ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
  }
  header{position:sticky;top:0;z-index:10;background:rgba(255,255,255,.9);backdrop-filter:saturate(1.1) blur(8px);border-bottom:1px solid #e8e9ef}
  .wrap{max-width:1200px;margin:0 auto;padding:18px 16px}
  h1{margin:0 0 8px;font-size:22px}
  .sub{color:var(--muted);font-size:14px;margin-bottom:12px}
  .controls{display:grid;grid-template-columns:1fr auto auto;gap:10px;align-items:center}
  input[type="search"],select{
    padding:12px 14px;border:1px solid #d9dbe3;border-radius:10px;background:#fff;color:var(--ink);font-size:14px
  }
  .pill{padding:10px 12px;border:1px solid #d9dbe3;border-radius:10px;background:#fff;font-size:13px}
  main{padding:22px 16px 60px}
  .grid{max-width:1200px;margin:0 auto;display:grid;gap:16px;grid-template-columns:repeat(auto-fill,minmax(320px,1fr))}
  .card{background:var(--card);border:1px solid #e6e7ec;border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;display:flex;flex-direction:column}
  .card-head{padding:12px 14px 10px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #eee}
  .title{font-weight:700;font-size:16px}
  .badge{font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1d4ed8;border:1px solid #dbe4ff}
  .svg-wrap{padding:12px 12px 0 12px}
  .meta{padding:10px 14px 12px;display:grid;gap:6px;color:#333;font-size:13px}
  .meta strong{font-weight:600}
  .options li{margin-left:18px}
  .actions{padding:10px 14px 14px;display:flex;flex-wrap:wrap;gap:8px;border-top:1px solid #eee}
  button{appearance:none;border:1px solid #d9dbe3;background:#fff;color:#111;padding:8px 10px;border-radius:10px;cursor:pointer;font-size:13px}
  button:hover{border-color:#b8bbca}
  .speed{display:inline-flex;align-items:center;gap:6px;margin-left:auto;font-size:12px;color:#444}
  .empty{color:#666;text-align:center;padding:30px}
  footer{color:#666;text-align:center;padding:24px;font-size:12px}

  /* Court styling */
  .court-line{stroke:var(--line);stroke-width:1.6;fill:none}
  .court-dash{stroke:var(--dash);stroke-width:1.4;stroke-dasharray:4 4;fill:none}
  .off{fill:var(--offense);stroke:#fff;stroke-width:1}
  .def{fill:var(--defense);stroke:var(--defense);stroke-width:1}
  .label{font-size:9px;fill:#111;font-weight:700;text-anchor:middle;dominant-baseline:middle}
  .label-off{fill:#fff}
  .arrow{stroke:var(--accent);stroke-width:2.2;fill:none;stroke-linecap:round}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>üèÄ Court Vision ‚Äî Animated Half-Court Plays</h1>
    <div class="sub">Numbered players (1‚Äì5), defenders (X1‚ÄìX5), slow full-play animation with passes (orange ball). Download SVG/PNG.</div>
    <div class="controls">
      <input id="search" type="search" placeholder="Search plays, tags, situations (e.g., spain, horns, hammer, zone, ATO)‚Ä¶" />
      <select id="filterTag">
        <option value="">All Tags</option>
        <option>man</option><option>PnR</option><option>ATO</option><option>zone</option><option>5-out</option><option>quick-hitter</option>
      </select>
      <div class="pill" id="count">0 plays</div>
    </div>
  </div>
</header>

<main>
  <div class="grid" id="grid"></div>
  <div class="empty" id="empty" hidden>No plays match your search/filter.</div>
</main>

<footer>Built for coaches & hoopers. Add more in <code>playsData</code>. ¬© Court Vision</footer>

<script>
/* =========================================================
   PLAY DATA
   - Each play can have either:
     A) sequence: [{ duration: seconds, offense:{1:{x,y},‚Ä¶}, defense:{1:{x,y},‚Ä¶}, pass:{from:1,to:3} }]
     B) arrows + initial offense/defense (legacy). Engine will auto-tween nearest dots along arrows and nudge defenders.
   - Coordinates are % (0..100) on HALF COURT. Origin at top-left, baseline at bottom.
========================================================= */
const playsData = [
  // --- RICH SEQUENCE EXAMPLE: Spain PnR ---
  {
    id:"spain-seq",
    name:"Spain PnR (Stack) ‚Äî animated",
    tag:"PnR man",
    goal:"Backscreen the roller to stress drop; hit roll/skip/short-roll",
    useWhen:"Strong roller + shooter who can screen",
    avoidWhen:"Switch-all with great comms",
    options:["Roll read","Skip to pop","Short-roll DHO"],
    offenseStart:{1:{x:12,y:82},2:{x:54,y:38},3:{x:22,y:56},4:{x:80,y:60},5:{x:46,y:50}},
    defenseStart:{1:{x:14,y:76},2:{x:54,y:48},3:{x:26,y:62},4:{x:76,y:66},5:{x:46,y:60}},
    ballHandler:1,
    sequence:[
      // bring 1 to PnR
      {duration:2.0, offense:{1:{x:32,y:64},5:{x:42,y:52}}, defense:{1:{x:28,y:66},5:{x:44,y:58}}},
      // set Spain backscreen by 2 on 5
      {duration:2.0, offense:{2:{x:46,y:44}}, defense:{2:{x:52,y:50}}},
      // turn the corner; pass to roller
      {duration:2.0, offense:{1:{x:46,y:58},5:{x:50,y:68}}, defense:{1:{x:44,y:60},5:{x:50,y:60}}, pass:{from:1,to:5}},
      // finish at rim
      {duration:1.5, offense:{5:{x:50,y:78}}, defense:{5:{x:50,y:66}}}
    ]
  },

  // --- RICH SEQUENCE EXAMPLE: Hammer ---
  {
    id:"hammer-seq",
    name:"Hammer (Baseline Drift) ‚Äî animated",
    tag:"man quick-hitter",
    goal:"Drive baseline + weakside hammer screen for corner 3",
    useWhen:"Help tags from strong side",
    avoidWhen:"No corner shooting threat",
    options:["Drift 3","Skip slot","Dump to dunker"],
    offenseStart:{1:{x:20,y:66},2:{x:18,y:78},3:{x:76,y:50},4:{x:88,y:66},5:{x:40,y:52}},
    defenseStart:{1:{x:24,y:62},2:{x:20,y:72},3:{x:72,y:56},4:{x:84,y:72},5:{x:40,y:60}},
    ballHandler:1,
    sequence:[
      {duration:2.0, offense:{1:{x:28,y:58},5:{x:44,y:56}}, defense:{1:{x:30,y:60},5:{x:44,y:60}}},
      // hammer screen by 4 for 3 in the corner
      {duration:2.0, offense:{4:{x:82,y:54},3:{x:88,y:50}}, defense:{4:{x:82,y:66},3:{x:76,y:56}}},
      // baseline drive + pass to corner
      {duration:2.0, offense:{1:{x:36,y:54}}, defense:{1:{x:38,y:56}}, pass:{from:1,to:3}},
      // shot / hold
      {duration:1.5, offense:{}, defense:{}}
    ]
  },

  // --- LEGACY: engine will auto-animate from arrows (everyone moves slowly) ---
  {
    id:"double-drag",
    name:"Double Drag (flow)",
    tag:"PnR man",
    goal:"Two staggered screens in early offense",
    useWhen:"Early vs drop or weak nail",
    avoidWhen:"Switch-heavy + physical guards",
    options:["Reject first","Hit pop","Shake 45"],
    offense:[ {x:10,y:82,label:"1"},{x:30,y:56,label:"4"},{x:42,y:52,label:"5"},{x:20,y:62,label:"2"},{x:80,y:62,label:"3"} ],
    defense:[ {x:14,y:76},{x:30,y:62},{x:42,y:62},{x:26,y:68},{x:74,y:68} ],
    arrows:[ {from:{x:10,y:82}, to:{x:48,y:58}} ]
  },
  {
    id:"five-out",
    name:"Motion 5-Out (read & react)",
    tag:"5-out man",
    goal:"Max spacing for drive/kick/DHOs",
    useWhen:"Good for flow vs any coverage",
    avoidWhen:"Need precise ATO",
    options:["Pass-cut-replace","Backdoor vs top lock","Quick DHO"],
    offense:[ {x:12,y:70,label:"1"},{x:28,y:48,label:"2"},{x:50,y:40,label:"4"},{x:72,y:48,label:"3"},{x:88,y:70,label:"5"} ],
    defense:[ {x:16,y:74},{x:30,y:56},{x:50,y:52},{x:70,y:56},{x:84,y:74} ],
    arrows:[ {from:{x:12,y:70}, to:{x:28,y:48}}, {from:{x:28,y:48}, to:{x:50,y:40}} ]
  }
];

/* =========================================================
   APP RENDER
========================================================= */
const grid = document.getElementById('grid');
const searchEl = document.getElementById('search');
const countEl  = document.getElementById('count');
const emptyEl  = document.getElementById('empty');
const filterTagEl = document.getElementById('filterTag');

function render(){
  grid.innerHTML='';
  const q=(searchEl.value||'').trim().toLowerCase();
  const tag=(filterTagEl.value||'').toLowerCase();
  const filtered = playsData.filter(p=>{
    const hay=[p.name,p.goal,p.useWhen,p.avoidWhen,(p.options||[]).join(' '),p.tag].join(' ').toLowerCase();
    const okQ = !q || hay.includes(q);
    const okT = !tag || (p.tag||'').toLowerCase().includes(tag);
    return okQ && okT;
  });
  filtered.forEach(p=>grid.appendChild(renderCard(p)));
  countEl.textContent=`${filtered.length} play${filtered.length===1?'':'s'}`;
  emptyEl.hidden = filtered.length>0;
}

function renderCard(play){
  const card=document.createElement('article'); card.className='card';
  const head=document.createElement('div'); head.className='card-head';
  head.innerHTML=`<div class="title">${play.name}</div><span class="badge">${play.tag||'play'}</span>`;
  card.appendChild(head);

  const svgWrap=document.createElement('div'); svgWrap.className='svg-wrap';
  const {svg, api}=buildHalfCourt(play); svgWrap.appendChild(svg); card.appendChild(svgWrap);

  const meta=document.createElement('div'); meta.className='meta';
  meta.innerHTML=`
    <div><strong>Goal:</strong> ${play.goal}</div>
    <div><strong>Use when:</strong> ${play.useWhen}</div>
    <div><strong>Avoid when:</strong> ${play.avoidWhen}</div>
    <div class="options"><strong>Options:</strong><ul>${(play.options||[]).map(o=>`<li>${o}</li>`).join('')}</ul></div>
  `;
  card.appendChild(meta);

  const actions=document.createElement('div'); actions.className='actions';
  const runBtn=btn("‚ñ∂ Run", ()=>api.run());
  const pauseBtn=btn("‚è∏ Pause", ()=>api.pause());
  const resetBtn=btn("‚ü≤ Reset", ()=>api.reset());
  const dlSvg=btn("Download SVG", ()=>downloadSVG(svg, `${play.id}.svg`));
  const dlPng=btn("Download PNG", ()=>downloadPNG(svg, `${play.id}.png`));
  const speedWrap=document.createElement('label'); speedWrap.className='speed'; speedWrap.innerHTML=`Speed <input type="range" min="0.5" max="2" step="0.1" value="1">`;
  speedWrap.querySelector('input').addEventListener('input',(e)=>api.setSpeed(parseFloat(e.target.value)));
  actions.append(runBtn,pauseBtn,resetBtn,dlSvg,dlPng,speedWrap);
  card.appendChild(actions);

  return card;
}
function btn(t,fn){const b=document.createElement('button'); b.textContent=t; b.onclick=fn; return b;}

/* =========================================================
   COURT (HALF) + ANIMATION ENGINE
========================================================= */
function buildHalfCourt(play){
  const W=380, H=280, PAD=12;
  const svg=NS('svg'); svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width','100%'); svg.setAttribute('height','240');

  // helpers
  const L=(x1,y1,x2,y2,cls='court-line')=>EL('line',{x1,y1,x2,y2,class:cls});
  const C=(cx,cy,r,cls='court-line')=>EL('circle',{cx,cy,r,class:cls});
  const R=(x,y,w,h,cls='court-line',rx=0)=>EL('rect',{x,y,width:w,height:h,class:cls,rx});
  const TX=(x,y,str,cls='label')=>EL('text',{x,y,class:cls},str);

  // draw half court (baseline at bottom)
  svg.appendChild(EL('rect',{x:0,y:0,width:W,height:H,fill:'#fff'}));
  // sidelines + baseline + midline
  svg.appendChild(L(PAD,PAD, W-PAD,PAD));                       // top (midcourt boundary)
  svg.appendChild(L(PAD,H-PAD, W-PAD,H-PAD));                   // baseline
  svg.appendChild(L(PAD,PAD, PAD,H-PAD));                       // left sideline
  svg.appendChild(L(W-PAD,PAD, W-PAD,H-PAD));                   // right sideline
  // top semicircle (center)
  svg.appendChild(C(W/2, PAD+26, 16));                          // small top-circle
  // lane (key)
  const laneW=160, laneH=120;
  svg.appendChild(R(W/2-laneW/2, H-PAD-laneH, laneW, laneH, 'court-line',6));
  // free-throw circle
  svg.appendChild(C(W/2, H-PAD-laneH, 32));                     // top half solid
  const dash = EL('path',{d:arcPath(W/2, H-PAD-laneH, 32, Math.PI, 2*Math.PI), class:'court-dash'}); svg.appendChild(dash);
  // rim & backboard
  svg.appendChild(C(W/2, H-PAD-18, 6));                         // rim
  svg.appendChild(L(W/2-18, H-PAD-18, W/2+18, H-PAD-18));       // cylinder line
  // 3-point arc (approx)
  const arcR=108, aStartX=W/2-92, aStartY=H-PAD-54, aEndX=W/2+92, aEndY=H-PAD-54;
  const three = EL('path',{d:`M ${aStartX} ${aStartY} A ${arcR} ${arcR} 0 0 1 ${aEndX} ${aEndY}`, class:'court-line'}); svg.appendChild(three);

  // styles used inside the SVG
  const style=EL('style',{},`
    .court-line{stroke:var(--line);stroke-width:1.6;fill:none}
    .court-dash{stroke:var(--dash);stroke-width:1.4;stroke-dasharray:4 4;fill:none}
    .off{fill:var(--offense);stroke:#fff;stroke-width:1}
    .def{fill:var(--defense);stroke:var(--defense);stroke-width:1}
    .label{font-size:9px;fill:#111;font-weight:700;text-anchor:middle;dominant-baseline:middle}
    .label-off{fill:#fff}
    .arrow{stroke:var(--accent);stroke-width:2.2;fill:none;stroke-linecap:round}
  `); svg.appendChild(style);

  // build player nodes
  const offNodes={}, defNodes={};
  // starting positions: from sequence or legacy arrays
  let startOff = play.offenseStart || mapLegacyPlayers(play.offense, true);
  let startDef = play.defenseStart || mapLegacyPlayers(play.defense, false);

  // draw offense (1..5) and labels
  for(let i=1;i<=5;i++){
    const p = startOff[i] || nearestFallback(startOff);
    const pt = toXY(p.x,p.y,W,H);
    const dot = C(pt.x,pt.y,7,'off'); svg.appendChild(dot);
    const lbl = TX(pt.x,pt.y,String(i),'label label-off'); svg.appendChild(lbl);
    offNodes[i]={dot,lbl,x:pt.x,y:pt.y};
  }
  // draw defense (X1..X5)
  for(let i=1;i<=5;i++){
    const p = startDef[i] || {x:50+i*3,y:55}; // fallback
    const pt = toXY(p.x,p.y,W,H);
    const dot = C(pt.x,pt.y,7,'def'); svg.appendChild(dot);
    const lbl = TX(pt.x,pt.y,'X'+i,'label'); svg.appendChild(lbl);
    defNodes[i]={dot,lbl,x:pt.x,y:pt.y};
  }

  // ball node (follows ballHandler; animates on passes)
  const ball = C(0,0,4); ball.setAttribute('fill','var(--ball)'); svg.appendChild(ball);
  let ballOwner = play.ballHandler || 1;

  // if legacy play: draw arrows & create auto-sequence
  let sequence = play.sequence;
  if(!sequence){
    sequence = buildAutoSequenceFromArrows(play, startOff, startDef);
  }

  // API + animation state
  let stepIdx=0, t=0, speed=1, playing=false, raf=null;

  // For each step, compute targets for all 10 players and (optional) pass
  const steps = sequence.map(st => normalizeStep(st, startOff, startDef));

  // set initial ball position
  positionBall(offNodes[ballOwner].dot);

  function run(){ if(playing) return; playing=true; raf=requestAnimationFrame(loop); }
  function pause(){ playing=false; }
  function reset(){
    playing=false; raf && cancelAnimationFrame(raf); raf=null; stepIdx=0; t=0;
    // reset to initial
    for(let i=1;i<=5;i++){
      const p=toXY(startOff[i].x,startOff[i].y,W,H); moveNode(offNodes[i],p.x,p.y,true);
      const q=toXY(startDef[i].x,startDef[i].y,W,H); moveNode(defNodes[i],q.x,q.y,true);
    }
    ballOwner = play.ballHandler || 1;
    positionBall(offNodes[ballOwner].dot,true);
  }
  function setSpeed(v){ speed=v; }

  function loop(){
    if(!playing){ raf=null; return; }
    const cur=steps[stepIdx];
    const dt = 0.016*speed;                 // ~60fps
    const dur = Math.max(0.001, cur.duration);
    t = Math.min(1, t + dt/dur);

    // interpolate all players
    for(let i=1;i<=5;i++){
      const oFrom=cur.offFrom[i], oTo=cur.offTo[i];
      const dFrom=cur.defFrom[i], dTo=cur.defTo[i];
      const ox = lerp(oFrom.x,oTo.x,t), oy=lerp(oFrom.y,oTo.y,t);
      const dx = lerp(dFrom.x,dTo.x,t), dy=lerp(dFrom.y,dTo.y,t);
      moveNode(offNodes[i],ox,oy);
      moveNode(defNodes[i],dx,dy);
    }

    // handle ball (follow owner or pass)
    if(cur.pass && t<1){
      // animate pass for first 60% of the step
      const passT = Math.min(1, t/0.6);
      const fromDot = offNodes[cur.pass.from].dot;
      const toDot   = offNodes[cur.pass.to].dot;
      const bx = lerp(fromDot.cx.baseVal.value, toDot.cx.baseVal.value, passEase(passT));
      const by = lerp(fromDot.cy.baseVal.value, toDot.cy.baseVal.value, passEase(passT));
      ball.setAttribute('cx',bx); ball.setAttribute('cy',by);
      if(passT>=1) ballOwner = cur.pass.to;
    } else {
      positionBall(offNodes[ballOwner].dot);
    }

    if(t>=1){
      // advance step
      stepIdx++;
      if(stepIdx>=steps.length){ playing=false; raf=null; return; }
      t=0;
    }
    raf=requestAnimationFrame(loop);
  }

  return { svg, api:{run,pause,reset,setSpeed} };
}

/* ---------- Helpers for animation ---------- */
function NS(tag){return document.createElementNS('http://www.w3.org/2000/svg',tag)}
function EL(tag,attrs={},text){const el=NS(tag);for(const k in attrs)el.setAttribute(k,attrs[k]);if(text!=null)el.textContent=text;return el;}
function toXY(px,py,W,H){const PAD=12, innerW=W-2*PAD, innerH=H-2*PAD;return {x:PAD+innerW*(px/100), y:PAD+innerH*(py/100)};}
function lerp(a,b,t){return a+(b-a)*t;}
function moveNode(node,x,y,instant=false){
  node.dot.setAttribute('cx',x); node.dot.setAttribute('cy',y);
  node.lbl.setAttribute('x',x);  node.lbl.setAttribute('y',y);
  if(instant){ node.x=x; node.y=y; }
}
function positionBall(ownerDot, instant){
  const bx=ownerDot.cx.baseVal.value, by=ownerDot.cy.baseVal.value;
  const ball = ownerDot.parentNode.querySelector('circle[fill="var(--ball)"]');
  ball.setAttribute('cx',bx); ball.setAttribute('cy',by);
}
function passEase(t){ // quick-out ease for passes
  return 1 - Math.pow(1-t,3);
}
function arcPath(cx,cy,r,a0,a1){ // used for dashed FT semicircle
  const sx = cx + r*Math.cos(a0), sy = cy + r*Math.sin(a0);
  const ex = cx + r*Math.cos(a1), ey = cy + r*Math.sin(a1);
  const large = (a1-a0) % (2*Math.PI) > Math.PI ? 1 : 0;
  return `M ${sx} ${sy} A ${r} ${r} 0 ${large} 1 ${ex} ${ey}`;
}
function mapLegacyPlayers(arr, offense){
  // Convert legacy arrays to {1..5:{x,y}}; fill missing labels with index order
  const map={};
  if(Array.isArray(arr)){
    arr.forEach((p,i)=>{
      const label = offense ? (p.label ? parseInt(p.label,10)||i+1 : i+1) : (i+1);
      map[label]={x:p.x,y:p.y};
    });
  }
  // fill remaining with spread positions if missing
  for(let i=1;i<=5;i++) if(!map[i]) map[i]={x:20+i*10,y:60};
  return map;
}
function nearestFallback(map){
  // return average point
  const vals=Object.values(map); if(!vals.length) return {x:50,y:60};
  const sx=vals.reduce((a,b)=>a+b.x,0), sy=vals.reduce((a,b)=>a+b.y,0);
  return {x:sx/vals.length, y:sy/vals.length};
}
function normalizeStep(step, startOff, startDef){
  // produce from‚Üíto for all players for this step
  const duration=step.duration||2.0;
  const offFrom={}, offTo={}, defFrom={}, defTo={};
  for(let i=1;i<=5;i++){
    offFrom[i]=clone(startOff[i]); defFrom[i]=clone(startDef[i]);
  }
  // apply targets
  const oT = step.offense||{}; const dT = step.defense||{};
  for(let i=1;i<=5;i++){
    offTo[i]=oT[i]?clone(oT[i]):clone(offFrom[i]);
    defTo[i]=dT[i]?clone(dT[i]):clone(defFrom[i]);
  }
  // update new "start" for next normalization
  for(let i=1;i<=5;i++){ startOff[i]=clone(offTo[i]); startDef[i]=clone(defTo[i]); }
  return {duration, offFrom, offTo, defFrom, defTo, pass: step.pass?{from:step.pass.from,to:step.pass.to}:null};
}
function clone(o){return {x:o.x,y:o.y};}

function buildAutoSequenceFromArrows(play, startOff, startDef){
  // Move nearest offense players along arrows; defenders shadow by small shifts.
  const seq=[];
  if(!play.arrows || !play.arrows.length){
    // idle hold so Run does something
    seq.push({duration:2, offense:{}, defense:{}});
    return seq;
  }
  // step 1: move offense along arrows
  const offenseTargets = {};
  play.arrows.forEach(a=>{
    const idx = nearestOffIndex(startOff, a.from);
    offenseTargets[idx]= {x:a.to.x, y:a.to.y};
  });
  // defenders nudge towards the lane / help positions
  const defenseTargets = {};
  for(let i=1;i<=5;i++){
    const p = startDef[i];
    // nudge 6% toward the ball side (toward min x of offenseTargets)
    const ballSide = Math.min(...Object.values(offenseTargets).map(t=>t.x).concat([50]));
    const dx = (ballSide - p.x)*0.12;
    const dy = (60 - p.y)*0.10;
    defenseTargets[i]={x:p.x+dx, y:p.y+dy};
  }
  seq.push({duration:3.0, offense:offenseTargets, defense:defenseTargets});
  // step 2: slight settle
  seq.push({duration:1.5, offense:{}, defense:{}});
  return seq;
}
function nearestOffIndex(startOff, from){
  // find offense player closest to 'from'
  let best=1, bestD=1e9;
  for(let i=1;i<=5;i++){
    const p=startOff[i];
    const d=(p.x-from.x)**2 + (p.y-from.y)**2;
    if(d<bestD){bestD=d; best=i;}
  }
  return best;
}

/* =========================================================
   EXPORTS (SVG / PNG)
========================================================= */
function svgToString(svg){
  const clone=svg.cloneNode(true);
  const style=document.createElement('style');
  style.textContent=`:root{--line:#111;--dash:#777;--offense:#e53935;--defense:#111;--accent:#1d4ed8;--ball:#ff8c00} text{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial}`;
  clone.insertBefore(style, clone.firstChild);
  const xml=new XMLSerializer().serializeToString(clone);
  return `<?xml version="1.0" encoding="UTF-8"?>\n`+xml;
}
function downloadSVG(svg, filename){
  const str=svgToString(svg);
  const blob=new Blob([str],{type:'image/svg+xml'});
  const url=URL.createObjectURL(blob);
  trigger(url,filename); setTimeout(()=>URL.revokeObjectURL(url),1200);
}
function downloadPNG(svg, filename){
  const str=svgToString(svg);
  const img=new Image();
  const url=URL.createObjectURL(new Blob([str],{type:'image/svg+xml'}));
  img.onload=function(){
    const w=svg.viewBox.baseVal.width||380, h=svg.viewBox.baseVal.height||280;
    const c=document.createElement('canvas'); c.width=w*3; c.height=h*3;
    const ctx=c.getContext('2d'); ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,c.width,c.height);
    ctx.drawImage(img,0,0,c.width,c.height);
    URL.revokeObjectURL(url);
    c.toBlob(b=>{const u=URL.createObjectURL(b); trigger(u,filename); setTimeout(()=>URL.revokeObjectURL(u),1200);},'image/png');
  };
  img.src=url;
}
function trigger(url,filename){const a=document.createElement('a');a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();}

/* =========================================================
   BOOT
========================================================= */
searchEl.addEventListener('input', render);
filterTagEl.addEventListener('change', render);
render();
</script>
</body>
</html>

